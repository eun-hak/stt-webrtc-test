<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>WebRTC STT Demo (Host Server)</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 20px;
      }
      #log {
        white-space: pre-wrap;
        background: #f6f6f6;
        padding: 8px;
        border-radius: 6px;
        height: 220px;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      }
      .partial {
        color: #666;
        font-style: italic;
      }
      .final {
        color: #111;
      }
      footer {
        margin-top: 12px;
        color: #666;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <h1>ChatBrain STT (WebRTC Demo - Host Server 8082)</h1>
    <div>
      <button id="btnStart">ë§ˆì´í¬ ì‹œì‘</button>
      <button id="btnStop" disabled>ì •ì§€</button>
      <select id="selDevice"></select>
      <button id="btnRefresh">ì¥ì¹˜ ìƒˆë¡œê³ ì¹¨</button>
    </div>
    <div id="status">idle</div>
    <h3>Transcript</h3>
    <div id="log"></div>
    <footer>2025 Â© SimSimi Inc. - Host WebRTC Server (Port 8082)</footer>

    <script>
      const btnStart = document.getElementById("btnStart");
      const btnStop = document.getElementById("btnStop");
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");

      let pc;
      let ws;
      let sessionId;
      const selDevice = document.getElementById("selDevice");
      const btnRefresh = document.getElementById("btnRefresh");

      async function refreshDevices() {
        // ë¯¸ë””ì–´ API ì§€ì› í™•ì¸
        if (
          !navigator.mediaDevices ||
          !navigator.mediaDevices.enumerateDevices
        ) {
          console.error(
            "Media Devices API not supported or not available in this context"
          );
          log(
            "âŒ ë¯¸ë””ì–´ APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. HTTPS ë˜ëŠ” localhostê°€ í•„ìš”í•©ë‹ˆë‹¤.",
            "final"
          );
          return;
        }

        const devices = await navigator.mediaDevices.enumerateDevices();
        const inputs = devices.filter((d) => d.kind === "audioinput");
        selDevice.innerHTML = "";
        for (const d of inputs) {
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || `input-${selDevice.length + 1}`;
          selDevice.appendChild(opt);
        }
        console.log(
          "audio inputs:",
          inputs.map((d) => ({ label: d.label, id: d.deviceId }))
        );
      }

      function log(line, cls = "final") {
        const div = document.createElement("div");
        div.className = cls;
        div.textContent = line;
        logEl.appendChild(div);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function pad2(n) {
        return n.toString().padStart(2, "0");
      }
      function pad3(n) {
        return n.toString().padStart(3, "0");
      }
      function formatTs(sec) {
        const s = Math.max(0, Number(sec) || 0);
        const hours = Math.floor(s / 3600);
        const minutes = Math.floor((s % 3600) / 60);
        const seconds = Math.floor(s % 60);
        const millis = Math.round((s - Math.floor(s)) * 1000);
        if (hours > 0) {
          return `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}.${pad3(
            millis
          )}`;
        } else {
          return `${pad2(minutes)}:${pad2(seconds)}.${pad3(millis)}`;
        }
      }

      async function start() {
        btnStart.disabled = true;
        btnStop.disabled = false;
        statusEl.textContent = "connecting...";
        sessionId = "S" + Math.random().toString(16).slice(2, 8);

        pc = new RTCPeerConnection();
        pc.oniceconnectionstatechange = () =>
          console.log("iceConnectionState", pc.iceConnectionState);
        pc.onconnectionstatechange = () =>
          console.log("connectionState", pc.connectionState);
        pc.onicegatheringstatechange = () =>
          console.log("iceGatheringState", pc.iceGatheringState);

        const selId = selDevice.value || undefined;
        const audioConstraints = selId
          ? {
              deviceId: { exact: selId },
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            }
          : {
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            };
        // ë¯¸ë””ì–´ API ì§€ì› í™•ì¸
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          console.error(
            "getUserMedia not supported or not available in this context"
          );
          log(
            "âŒ ë§ˆì´í¬ ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. HTTPS ë˜ëŠ” localhostê°€ í•„ìš”í•©ë‹ˆë‹¤.",
            "final"
          );
          btnStart.disabled = false;
          btnStop.disabled = true;
          statusEl.textContent = "failed";
          return;
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: audioConstraints,
        });
        const tracks = stream.getAudioTracks();
        console.log(
          "tracks",
          tracks.map((t) => ({
            label: t.label,
            muted: t.muted,
            enabled: t.enabled,
            ready: t.readyState,
          }))
        );
        for (const track of tracks) {
          track.onmute = () => console.log("track mute");
          track.onunmute = () => console.log("track unmute");
          pc.addTrack(track, stream);
        }

        // WebSocket for transcript - HTTPSì—ì„œëŠ” wss:// ì‚¬ìš©
        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsHost = location.host; // í¬íŠ¸ í¬í•¨ëœ í˜¸ìŠ¤íŠ¸ ì‚¬ìš©
        const wsUrl = `${wsProtocol}//${wsHost}/ws/transcript?session=${sessionId}`;
        console.log("ğŸ”Œ WebSocket URL:", wsUrl);
        console.log("ğŸ“ Current protocol:", location.protocol);
        console.log("ğŸ  Current host:", location.host);
        ws = new WebSocket(wsUrl);
        ws.onopen = () => console.log("ws open");
        ws.onclose = (e) => console.log("ws close", e.code, e.reason);
        ws.onerror = (e) => console.log("ws error", e);
        ws.onmessage = (e) => {
          try {
            const msg = JSON.parse(e.data);
            if (msg.type === "final") {
              (msg.segments || []).forEach((seg) =>
                log(
                  `${formatTs(seg.start)} - ${formatTs(seg.end)}  ${seg.text}`,
                  "final"
                )
              );
            } else if (msg.type === "partial") {
              log(`[partial] ${msg.text}`, "partial");
            } else if (msg.type === "info") {
              statusEl.textContent = msg.message;
              console.log("info", msg.message);
            }
          } catch {}
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        // Wait for ICE gathering to complete (non-trickle)
        await new Promise((resolve) => {
          if (pc.iceGatheringState === "complete") return resolve();
          const check = () => {
            if (pc.iceGatheringState === "complete") {
              pc.removeEventListener("icegatheringstatechange", check);
              resolve();
            }
          };
          pc.addEventListener("icegatheringstatechange", check);
        });
        const finalOffer = pc.localDescription;
        console.log("sending offer with ICE");
        // WebRTC offerë¥¼ ê°™ì€ ì„œë²„ë¡œ ì „ì†¡ - HTTPSì—ì„œëŠ” https:// ì‚¬ìš©
        const httpProtocol =
          location.protocol === "https:" ? "https:" : "http:";
        const res = await fetch(
          `${httpProtocol}//${location.host}/webrtc/offer`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              sdp: finalOffer.sdp,
              type: finalOffer.type,
              session_id: sessionId,
              channel_id: "C01",
            }),
          }
        );
        const answer = await res.json();
        await pc.setRemoteDescription(answer);
        statusEl.textContent = "streaming";
      }

      async function stop() {
        btnStart.disabled = false;
        btnStop.disabled = true;
        statusEl.textContent = "stopped";
        if (ws) {
          try {
            ws.close();
          } catch {}
          ws = null;
        }
        if (pc) {
          pc.getSenders().forEach((s) => {
            try {
              s.track && s.track.stop();
            } catch {}
          });
          pc.close();
          pc = null;
        }
      }

      btnStart.onclick = start;
      btnStop.onclick = stop;
      btnRefresh.onclick = refreshDevices;

      // ë³´ì•ˆ ì»¨í…ìŠ¤íŠ¸ í™•ì¸
      function checkSecurityContext() {
        const isSecure = window.isSecureContext;
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;

        console.log("Security Context:", {
          isSecure,
          protocol,
          hostname,
          mediaDevices: !!navigator.mediaDevices,
        });

        if (!isSecure) {
          log(
            "âš ï¸ ë¹„ë³´ì•ˆ ì»¨í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤. HTTPS ë˜ëŠ” localhost ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.",
            "final"
          );
        }

        if (!navigator.mediaDevices) {
          log("âŒ ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ë¯¸ë””ì–´ APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "final");
        }
      }

      checkSecurityContext();
      refreshDevices();
    </script>
  </body>
</html>
